# 📖 使用场景示例

## 场景 1：企业微信代码传输

### 背景
你在微众银行工作，同事通过企业微信发来一段 Java 代码，需要合并到你的代码中。

### 传统做法（痛苦 😫）
1. 复制同事的代码到记事本
2. 打开你的代码文件
3. 肉眼逐行对比，容易漏掉细节
4. 手动复制粘贴，容易出错
5. 反复确认，耗时 20-30 分钟

### 使用本工具（高效 ⚡）

**步骤：**
1. 打开浏览器访问 `http://localhost:5678`
2. 左侧粘贴你的代码
3. 右侧粘贴同事的代码
4. 点击"对比分析"
5. 3 秒内看到彩色高亮的所有差异

**结果：**
```
📊 变更统计：
  • 新增：3 个方法
  • 修改：2 个方法
  • 新增：2 个 import 语句

💡 合并建议：
  ✅ 新增方法 deleteUser，建议接受
  ⚠️  修改方法 getUserById，需要人工审查
    原签名: public User getUserById(Long id)
    新签名: public User getUserById(Long id) throws UserNotFoundException
```

**效率提升：10 倍！** 从 30 分钟缩短到 3 分钟。

---

## 场景 2：跨环境代码同步

### 背景
你需要将内网环境的代码同步到外网环境，但两边的配置文件有差异。

### 问题
- 配置项很多（数据库地址、端口、密钥等）
- 不能全部覆盖，需要保留部分配置
- 容易搞混，导致生产事故

### 解决方案

**使用工具对比配置文件：**

```bash
python merge_assistant.py compare config_internal.properties config_external.properties
```

**输出：**
```
🔍 详细差异：

⚠️  [行 5 → 5]
  - database.url=jdbc:mysql://internal-db:3306/prod
  + database.url=jdbc:mysql://external-db:3306/prod
  💡 建议：保留基准版本（生产环境配置）

⚠️  [行 12 → 12]
  - api.key=internal-key-xxx
  + api.key=external-key-yyy
  💡 建议：保留基准版本（生产环境配置）

+ [行 20] # 新增的外网专用配置
+ [行 21] proxy.enabled=true
```

**价值：**
- ✅ 清晰看到所有配置差异
- ✅ 避免误覆盖生产配置
- ✅ 减少配置错误导致的事故

---

## 场景 3：代码审查

### 背景
你是 Tech Lead，需要审查团队成员提交的代码变更。

### 传统做法
- 在 Git diff 中查看，但格式不够直观
- 需要来回切换文件
- 难以快速把握整体变更

### 使用本工具

**步骤：**
1. 获取两个版本的代码
2. 使用 Web 界面对比
3. 快速识别关键变更

**优势：**
- 🎨 彩色高亮，一目了然
- 📊 统计摘要，快速了解变更规模
- 💡 智能建议，辅助决策

**示例输出：**
```
📈 变更统计：
  • 新增：5 行
  • 删除：1 行
  • 修改：2 行

💡 合并建议：
【高优先级】
  ⚠️  修改方法 updateUser，需要人工审查
    原签名: public void updateUser(User user)
    新签名: public void updateUser(User user) throws ValidationException
  ⚠️  删除方法 deprecatedMethod，需要确认是否必要

【中优先级】
  ✅ 新增导入语句，建议接受
```

---

## 场景 4：多人协作冲突解决

### 背景
你和同事同时修改了同一个文件，需要合并双方的改动。

### 问题
- Git merge 冲突标记不够直观
- 不确定应该保留哪个版本
- 担心合并后引入 bug

### 解决方案

**使用工具对比：**
1. 左侧粘贴你的版本
2. 右侧粘贴同事的版本
3. 查看详细差异和建议

**工具会告诉你：**
- 哪些是纯新增（可以直接接受）
- 哪些是修改（需要仔细审查）
- 哪些是删除（需要确认必要性）

**最终：**
- ✅ 清晰了解所有变更
- ✅ 做出明智的合并决策
- ✅ 避免引入 bug

---

## 场景 5：重构代码对比

### 背景
你重构了一个类，想确认是否遗漏了某些逻辑。

### 使用工具

**对比重构前后的代码：**
```bash
python merge_assistant.py compare UserService_old.java UserService_new.java
```

**工具会帮你：**
- 识别所有被删除的方法（确保没有误删）
- 识别所有新增的方法（确认重构目标）
- 识别所有修改的方法（确认逻辑一致性）

**价值：**
- ✅ 确保重构完整性
- ✅ 避免遗漏业务逻辑
- ✅ 提高重构信心

---

## 场景 6：学习他人代码

### 背景
你接手了一个项目，想快速了解前任开发者做了哪些改动。

### 使用工具

**对比不同版本：**
1. 获取旧版本代码
2. 获取新版本代码
3. 使用工具对比

**快速了解：**
- 新增了哪些功能（新方法）
- 修改了哪些逻辑（修改的方法）
- 删除了哪些代码（废弃的功能）

**价值：**
- ✅ 快速熟悉代码库
- ✅ 理解演进历史
- ✅ 避免重复造轮子

---

## 实际效果对比

| 场景 | 传统方式耗时 | 使用工具耗时 | 效率提升 |
|------|------------|------------|---------|
| 企业微信代码合并 | 20-30 分钟 | 2-3 分钟 | **10 倍** |
| 配置文件同步 | 15-20 分钟 | 2 分钟 | **8 倍** |
| 代码审查 | 10-15 分钟 | 3-5 分钟 | **3 倍** |
| 冲突解决 | 30-40 分钟 | 5-10 分钟 | **5 倍** |
| 重构验证 | 20-30 分钟 | 3-5 分钟 | **6 倍** |

---

## 用户反馈

> "以前合并代码要对着两个屏幕看半天，现在 3 秒就能看到所有差异，太爽了！"  
> —— 某银行 Java 开发工程师

> "彩色高亮真的很直观，再也不会漏掉细节了。"  
> —— 某证券公司前端工程师

> "在封闭的金融环境中，这个工具简直是救星！"  
> —— 某保险公司 Tech Lead

---

## 下一步

1. 🚀 立即试用：`python web_ui.py`
2. 📝 用真实代码测试
3. 💡 分享给团队成员
4. 🎯 根据需求定制规则

**让代码合并不再痛苦！** 🎉
